"""
Generate a C++ file containing the numbers in BESIII_CovMat.root

This can then be compiled/linked to the chi2 function, so that
we don't have to open/read a ROOT file every time we want to
evaluate it

"""
import pathlib
from typing import Tuple, TextIO
from datetime import datetime
import uproot
import numpy as np


def _write_header(handle: TextIO) -> None:
    """
    Write the file docstring

    """
    header = (
        "/*\n"
        " * BES-III Covariance Matrix\n"
        f" * Auto generated by {__file__}\n"
        f" * On {datetime.now()}\n"
        " */\n\n"
        "#include <TMatrixD.h>\n\n"
    )
    handle.write(header)


def _write_fcn(
    handle: TextIO, matrix: np.ndarray, shape: Tuple[int, int], name: str
) -> None:
    """
    Write a fcn that returns a matrix to the cpp file

    """
    assert len(matrix) == shape[0] * shape[1]

    handle.write(f"TMatrixD {name}(void) " "{\n    const double arr[] = {\n")

    for i in range(shape[0]):
        handle.write("    ")
        handle.write(
            ", ".join(
                f"{number:.20f}" for number in matrix[i * shape[1] : (i + 1) * shape[1]]
            )
        )
        handle.write(",\n")
    handle.write("    };\n")

    handle.write(f"    TMatrixD matrix = TMatrixD({shape[0]}, {shape[1]}, arr);\n")
    handle.write("    return matrix;\n}\n\n")


def _write_vector(handle: TextIO, names: Tuple[str, ...]):
    """
    Write a function returning a vector of TMatrixD objects

    """
    handle.write("std::vector<TMatrixD> vectors(void) {\n")

    # Creates vector of TMatrixDs
    handle.write("    return std::vector<TMatrixD> {\n")
    for name in names:
        handle.write(f"        {name}(),\n")
    handle.write("    };\n")

    handle.write("}")


def main():
    """
    Read the ROOT file; dump its contents to a C++ file that can be compiled

    """
    parent_dir = pathlib.Path(__file__).parents[0]
    root_file_path = parent_dir / "BESIII_CovMat.root"
    out_file_path = parent_dir / "besIII_covmat.cpp"

    # We need to build the vector of matrices in the right order
    # This is annoyingly slightly different to the order that
    # they are stored in the ROOT file
    keys = (
        "CPCOV",
        "REkpi",
        "Sk3pi",
        "LSCOV",
        "REOS",
        "Sk3pi2",
        "LSCOVp",
        "REOSp",
        "_NM_kspipi2",
        "TCOVS_kspipi2",
        "_NM_kspipi",
        "_COVS_kspipi",
        "ciCOV",
        "kiCOV",
        "BrCOV",
        "deltakpiCOV",
        "ciVal",
        "kiVal",
        "BrVal",
        "deltakpiVal",
        "REeff1",
        "REeff3",
        "COV2",
        "Sk3piLS",
        "Sk3piLSp",
    )

    with uproot.open(root_file_path) as root_f, open(out_file_path, "w") as out_f:
        _write_header(out_f)

        for k in keys:
            size = (root_f[k].member("fNrows"), root_f[k].member("fNcols"))
            _write_fcn(out_f, root_f[k].member("fElements"), size, k)

        # Fcn that returns a vector of matrices
        _write_vector(out_f, keys)


if __name__ == "__main__":
    main()
